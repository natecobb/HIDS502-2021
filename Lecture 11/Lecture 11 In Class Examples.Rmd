---
title: "Lecture 11 In Class Examples"
author: "Nathan Cobb"
date: "11/8/2021"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(tidyverse) # loads the tidyverse tools
library(DBI) # loads our database interface
library(RPostgres) # loads the database driver for PostgreSQL
library(connections) # helps RPostgres work with RStudio


# Normally we would use `DBI::dbConnect()` here, but the `RPostgres` library
# doesn't integrate with the RStudio connections pane. This works around that fact.
con <- connection_open(RPostgres::Postgres(),
          dbname = "syntheticmguh",
          host = "35.199.26.47",
          user = "hids502_student",
          password = "pursuit-parson-trivial",
          # Tell the driver to return very large integers as floating point (vs truncating them)
          bigint = "numeric")
```

# Class Examples

## Big Data

```{sql connection=con}
WITH observations_per_encounter AS (
    SELECT encounter, count(*) as heart_rate_observations
    from observations
    where code = '8867-4'
    group by encounter)
SELECT avg(heart_rate_observations)
FROM observations_per_encounter;
```

```{sql connection=con}
SELECT patient, encounter,
       date, bodysite_code, bodysite_description,
       modality_code, modality_description
FROM imaging_studies
```

## String Matching

```{sql connection=con}
SELECT count(*)
FROM notes 
WHERE LOWER(note_text) LIKE '%hea_ache%' OR LOWER(note_text) LIKE '%migraine%'
```

```{sql connection=con}
SELECT count(*)
FROM notes
WHERE note_text ~* 'headache|migraine'
```

```{sql connection=con}
SELECT 
  'Cobb' as name,
  soundex('Cobb') as soundex_name,
  metaphone('Cobb', 10) as metaphone_name
```

```{sql connection=con}
SELECT 
  levenshtein('Cobb', 'Kobb') Cobb_Kobb,
  levenshtein('Cobb', 'Kob') Cobb_Kob,
  levenshtein('Cobb', 'Frank') Cobb_Frank
```



```{sql connection=con}
select apr1.first, apr1.last, count(DISTINCT apr1.enterpriseid)
FROM patient_matching_challenge.all_patient_records AS apr1
-- This is a self-join, we are going to join the same table to
-- itself; to do so we need to give each copy a unique name
LEFT JOIN patient_matching_challenge.all_patient_records AS apr2
 ON apr1.last = apr2.last and apr1.first = apr2.first
  -- Lets only take records on the right hand side where they aren't
  -- the record on the left!
  AND apr1.enterpriseid <> apr2.enterpriseid
-- Here we limit to just records (on the left) that have both
-- a first and last name
WHERE apr1.last IS NOT NULL and apr1.first IS NOT NULL
-- Now group by enterpriseid; the names are redundant to helpful to us
GROUP BY apr1.enterpriseid, apr1.first, apr1.last
-- But only records where there are more than 1 copy
HAVING count(DISTINCT apr1.enterpriseid) > 1
ORDER BY count(DISTINCT apr1.enterpriseid) desc
LIMIT 5;
```

