---
title: "Lecture 03 Project Template"
author: "Nathan Cobb"
date: "9/13/2021"
output: html_document
---

This is an example RMarkdown document that shows how to connect to the Synthetic MGUH database (a PostgreSQL database in the Google Cloud environment). RMarkdown is most commonly used to execute chunks of R code sequentially, but can be used for many different kinds of code, including Python or even SQL. Here we will use it as a wrapper around SQL and RStudio as a basic interface to our database to query the database.

After executing the first chunk, you should have be able to see "syntheticmguh" in the connections pane and use that to browse the tables and fields.

```{r}
library(tidyverse) # loads the tidyverse tools
library(DBI) # loads our database interface
library(RPostgres) # loads the database driver for PostgreSQL
library(connections) # helps RPostgres work with RStudio


# Normally we would use `DBI::dbConnect` here, but the `RPostgres` library
# doesn't integrate with the RStudio connections pane. This works around that fact.
# If you use `odbc` then you don't need this. 
con <- connection_open(RPostgres::Postgres(),
          dbname = "syntheticmguh",
          host = "35.199.26.47",
          user = "hids502_student",
          password = "pursuit-parson-trivial",
          bigint = "numeric")
```

# Question 1

How many providers and payers are represented in the data set?

```{sql connection=con}
-- Your code goes here
SELECT COUNT(DISTINCT id) AS patients FROM patients
```
```{sql connection=con}
-- Your code goes here
SELECT COUNT(DISTINCT id) AS payers FROM payers
```
# Question 2

What is the mean amount spent per patient?

This contains the lifetime expenses for patients
```{sql connection=con}
SELECT AVG(healthcare_expenses) FROM patients
```

What does this look like per year?

```{sql connection=con}
-- Your code goes here
SELECT date_part('year', start) as claim_year, 
sum(total_claim_cost) total_claim_costs, 
count(distinct patient) as patients, 
sum(total_claim_cost) / count(distinct patient) as avg_expenses
FROM encounters
-- Having data from as far back as 1910 is a bid odd. Lets trim that
WHERE start >= '2011-01-01'
GROUP BY claim_year
ORDER BY claim_year DESC
```


# Question 3

What is the mean amount spent for Medicare patients?
What does this look like per year?

Note that this query shows just Medicare claims - this is different from saying "what are the total costs for someone who has Medicare, regardless of whether or not Medicare is the payer"!
```{sql connection=con}
SELECT date_part('year', start) as claim_year, sum(total_claim_cost), count(distinct patient) as patients, 
sum(total_claim_cost) / count(distinct patient) as avg_expenses
FROM encounters
 INNER JOIN payers ON encounters.payer = payers.id
   AND payers.name = 'Medicare'
WHERE start >= '2011-01-01'
GROUP BY claim_year
ORDER BY claim_year DESC
```

# Question 4

What is the min/max and mean number of patients per provider?

```{sql connection=con}
WITH provider_patient_count AS (
 SELECT provider, COUNT(DISTINCT patient) patient_count 
 FROM encounters
 -- We will restrict to the last year for convenience ...
 WHERE start >= '2019-01-01'
 GROUP BY provider
)
SELECT 
  MIN(patient_count) min_patients,
  MAX(patient_count) max_patients,
  AVG(patient_count) avg_patients
FROM provider_patient_count
```

Plot this as a boxplot – this will require you to use R

Here's an example of a boxplot

Like many EMR's there's no concept of a patient "belonging" to a provider, so we need to use encounters to determine this. We will do this is a two step process:

```{sql connection=con, output.var="patients_df"}
-- Here we use `output.var` to assign the results of the query to a variable
-- rather than printing!
 SELECT provider, COUNT(DISTINCT patient) patient_count 
 FROM encounters
 WHERE start >= '2019-01-01'
 GROUP BY provider
```

The boxplot isn't super useful due to the outliers
```{r}
mutate(patients_df, patient_count = as.integer(patient_count)) %>%
  ggplot() + 
  geom_boxplot(aes(x = patient_count))
```

Well thats a little wierd - thats an aweful lot of patients for one person to see! Who is this?

```{sql connection=con}
WITH provider_patient_count AS (
 SELECT provider, COUNT(DISTINCT patient) patient_count 
 FROM encounters
 WHERE start >= '2019-01-01'
 GROUP BY provider
)
SELECT providers.id, providers.name, providers.speciality, patient_count
FROM provider_patient_count
LEFT JOIN providers ON providers.id = provider
ORDER BY patient_count DESC 
LIMIT 1
```
Thats probably not really possible in the real world - this means she would see about 60 patients per day, all new. There are some scenarios where this could be theoretically be possible, but its probably a glitch of the artificial data.

In reality there the data are distributed with a large right side tail, with a small number of providers seeing an almost impossible number of patients. If we drop 

```{r}
filter(patients_df, patient_count < 500) %>%
  mutate(patient_count = as.integer(patient_count)) %>%
  ggplot() + 
  geom_boxplot(aes(x = patient_count))
```

# Question 5

What is the min/max and mean number of encounters per patient in 2019? 

Here we say "how many encounters did patients have - who had at least one encounter"

```{sql connection=con}
WITH patient_encounter_count AS (
 SELECT patient, COUNT(DISTINCT id) encounter_count 
 FROM encounters
 WHERE start >= '2009-01-01' AND start < '2010-01-01'
 GROUP BY patient
)
SELECT 
  MIN(encounter_count) min_encounters,
  MAX(encounter_count) max_encounters,
  AVG(encounter_count) avg_encounters
FROM patient_encounter_count
```

But if we meant all of our patients, regardless of whether they had an encounter or not, it looks a bit different ...
```{sql connection=con}
WITH patient_encounter_count AS (
 SELECT patients.id patient, COUNT(DISTINCT encounters.id) encounter_count 
 FROM patients 
 LEFT JOIN encounters 
   ON encounters.patient = patients.id
   -- IMPORTANT you need to filter in the join.
   -- if you filter in a WHERE statement you will lose the patients without data
   AND start >= '2009-01-01' AND start < '2010-01-01'
 GROUP BY patients.id
)
SELECT 
  COUNT(DISTINCT patient) patients,
  MIN(encounter_count) min_encounters,
  MAX(encounter_count) max_encounters,
  AVG(encounter_count) avg_encounters
FROM patient_encounter_count
```


Plot the distribution as a histogram – this will require you to use R

```{sql connection=con, output.var="encounters_df"}
 SELECT patient, COUNT(DISTINCT id) encounter_count 
 FROM encounters
 WHERE start >= '2009-01-01' AND start < '2010-01-01'
 GROUP BY patient
```

Histogram tells that the vast majority of patients really only had 1 encounter in 2009

```{r}
ggplot(encounters_df) + 
  geom_histogram(aes(x = encounter_count))  
```

